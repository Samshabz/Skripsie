import cv2  # OpenCV for image processing
import numpy as np  # For numerical operations
import os  # For file operations
import matplotlib.pyplot as plt  # For plotting

class UAVNavigator:
    def __init__(self, gps_to_pixel_scale):
        self.gps_to_pixel_scale = gps_to_pixel_scale  # Pixels per meter
        self.stored_images = []
        self.stored_keypoints = []
        self.stored_descriptors = []
        self.stored_gps = []

        # Initialize the SIFT detector
        self.sift = cv2.SIFT_create()

    def clear_stored_data(self):
        """Clear stored images, keypoints, descriptors, and GPS data."""
        self.stored_images = []
        self.stored_keypoints = []
        self.stored_descriptors = []
        self.stored_gps = []

    def crop_image(self, image, kernel_to_test):
        """Crop the top and bottom 10% of the image."""
        height = image.shape[0]

        cropped_image = image[int(height * 0.1):int(height * 0.9), :]
        cropped_image = cv2.GaussianBlur(cropped_image, (kernel_to_test, kernel_to_test), 0)  # Denoise

        return cropped_image

    def add_image(self, image, gps_coordinates, kernel_to_test):
        """Add an image and its GPS coordinates to the stored list."""
        cropped_image = self.crop_image(image, kernel_to_test)
        keypoints, descriptors = self.sift.detectAndCompute(cropped_image, None)
        self.stored_images.append(cropped_image)
        self.stored_keypoints.append(keypoints)
        self.stored_descriptors.append(descriptors)
        self.stored_gps.append(gps_coordinates)

    def compute_pixel_shifts(self, keypoints1, descriptors1, keypoints2, descriptors2):
        bf = cv2.BFMatcher()
        matches = bf.knnMatch(descriptors1, descriptors2, k=2)

        good_matches = []
        for m, n in matches:
            if m.distance < 0.75 * n.distance:
                good_matches.append(m)

        if len(good_matches) < 1:
            return None

        src_pts = np.float32([keypoints1[m.queryIdx].pt for m in good_matches])
        dst_pts = np.float32([keypoints2[m.trainIdx].pt for m in good_matches])

        shifts = dst_pts - src_pts
        return shifts

    def analyze_matches(self):
        ratios_x = []
        ratios_y = []
        for i in reversed(range(1, len(self.stored_images))):  # iterate through all images in reverse order
            current_image = self.stored_images[i]
            best_index = -1
            max_good_matches = 0
            optimal_scaling_factor_x = None
            optimal_scaling_factor_y = None

            for j in range(i):  # iterate through all images before the current image
                shifts = self.compute_pixel_shifts(self.stored_keypoints[i], self.stored_descriptors[i], self.stored_keypoints[j], self.stored_descriptors[j])  # compute pixel shifts between the current image and the previous image
                if shifts is not None and len(shifts) > max_good_matches:  # if the number of good matches is greater than the current max, update the max and the best index
                    max_good_matches = len(shifts)
                    best_index = j

            if best_index != -1:
                shifts = self.compute_pixel_shifts(self.stored_keypoints[i], self.stored_descriptors[i], self.stored_keypoints[best_index], self.stored_descriptors[best_index])
                if shifts is not None:
                    # Calculate pixel changes for x and y directions separately
                    pixel_changes_x = np.abs(shifts[:, 0]).round().astype(int)
                    pixel_changes_y = np.abs(shifts[:, 1]).round().astype(int)
                    temp = pixel_changes_x
                    pixel_changes_x = pixel_changes_y * 1.6906578125392608 * 1.0091360036480883
                    pixel_changes_y = temp * 2.012909744822167 * 0.9882405214428217

                    actual_gps_diff = np.array(self.stored_gps[i]) - np.array(self.stored_gps[best_index])
                    actual_gps_diff_meters = actual_gps_diff * 111139  # Convert degrees to meters

                    # Convert GPS differences to pixel changes for x and y
                    actual_pixel_change_x_mock = (actual_gps_diff_meters[0] * self.gps_to_pixel_scale).round().astype(int)
                    actual_pixel_change_y_mock = (actual_gps_diff_meters[1] * self.gps_to_pixel_scale).round().astype(int)
                    actual_pixel_change_x = np.abs(actual_pixel_change_x_mock)
                    actual_pixel_change_y = np.abs(actual_pixel_change_y_mock)

                    perfect_ratio_x = actual_pixel_change_x / np.mean(pixel_changes_x)
                    perfect_ratio_y = actual_pixel_change_y / np.mean(pixel_changes_y)
                    
                    ratios_x.append(perfect_ratio_x)
                    ratios_y.append(perfect_ratio_y)

                    # Calculate the estimated GPS difference
                    estimated_gps_diff_meters_x = np.mean(pixel_changes_x) / self.gps_to_pixel_scale
                    estimated_gps_diff_meters_y = np.mean(pixel_changes_y) / self.gps_to_pixel_scale
                    estimated_gps_diff_x = estimated_gps_diff_meters_x / 111139
                    estimated_gps_diff_y = estimated_gps_diff_meters_y / 111139

                    # Calculate estimated GPS coordinates
                    estimated_gps_x = self.stored_gps[best_index][0] + estimated_gps_diff_x
                    estimated_gps_y = self.stored_gps[best_index][1] + estimated_gps_diff_y
                    estimated_gps = (estimated_gps_x, estimated_gps_y)

                    # Calculate deviation in meters
                    deviation_x_meters = abs(estimated_gps_diff_meters_x - actual_gps_diff_meters[0])
                    deviation_y_meters = abs(estimated_gps_diff_meters_y - actual_gps_diff_meters[1])

                    print(f'Actual GPS: {self.stored_gps[i]}')
                    print(f'Estimated GPS: {estimated_gps}')
                    print(f'Deviation X (meters): {deviation_x_meters}')
                    print(f'Deviation Y (meters): {deviation_y_meters}')

                    # Plot histogram for x changes
                    plt.figure(figsize=(12, 6))
                    plt.subplot(1, 2, 1)
                    plt.hist(pixel_changes_x, bins=np.arange(pixel_changes_x.min(), pixel_changes_x.max() + 1), alpha=0.75, label='Estimated Pixel Changes X')
                    plt.axvline(x=actual_pixel_change_x, color='red', linestyle='--', label='Actual GPS Pixel Change X')
                    plt.title(f'Pixel Change Distribution X for Image {i+1} with Image {best_index+1}')
                    plt.xlabel('Pixel Change X (rounded)')
                    plt.ylabel('Frequency')
                    plt.legend()

                    # Plot histogram for y changes
                    plt.subplot(1, 2, 2)
                    plt.hist(pixel_changes_y, bins=np.arange(pixel_changes_y.min(), pixel_changes_y.max() + 1), alpha=0.75, label='Estimated Pixel Changes Y')
                    plt.axvline(x=actual_pixel_change_y, color='red', linestyle='--', label='Actual GPS Pixel Change Y')
                    plt.title(f'Pixel Change Distribution Y for Image {i+1} with Image {best_index+1}')
                    plt.xlabel('Pixel Change Y (rounded)')
                    plt.ylabel('Frequency')
                    plt.legend()

                    plt.tight_layout()
                    plt.show()
                    
        return np.std(ratios_x), np.std(ratios_y), np.mean(ratios_x), np.mean(ratios_y)


def parse_gps(file_path):
    """Parse GPS coordinates from a text file."""
    with open(file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()
        lat_str = lines[0].strip()
        lon_str = lines[1].strip()
        lat_deg, lat_min, lat_sec, lat_dir = parse_dms(lat_str)
        lon_deg, lon_min, lon_sec, lon_dir = parse_dms(lon_str)
        lat = convert_to_decimal(lat_deg, lat_min, lat_sec, lat_dir)
        lon = convert_to_decimal(lon_deg, lon_min, lon_sec, lon_dir)
        return lat, lon

def parse_dms(dms_str):
    dms_str = dms_str.replace('Â°', ' ').replace('\'', ' ').replace('"', ' ')
    parts = dms_str.split()
    deg = int(parts[0])
    min = int(parts[1])
    sec = float(parts[2])
    dir = parts[3]
    return deg, min, sec, dir

def convert_to_decimal(deg, min, sec, dir):
    decimal = deg + min / 60.0 + sec / 3600.0
    if dir in ['S', 'W']:
        decimal = -decimal
    return decimal

def main():
    
    gps_to_pixel_scale = 596 / 1092  # Pixels per meter
    navigator = UAVNavigator(gps_to_pixel_scale)
    directory = './GoogleEarth/SET1'
    num_images = 10
    kernels_to_test = [29]
    for num_kernels_to_test in kernels_to_test:
        navigator.clear_stored_data()  # Clear stored data before each kernel test
        for i in range(1, num_images + 1):  # Assuming there are 10 images
            image_path = os.path.join(directory, f'{i}.jpg')
            gps_path = os.path.join(directory, f'{i}.txt')
            image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
            gps_coordinates = parse_gps(gps_path)
            navigator.add_image(image, gps_coordinates, num_kernels_to_test)

        std_x, std_y, mean_x, mean_y = navigator.analyze_matches()
        print(f'Standard deviation of pixel change X: {std_x}')
        print(f'Standard deviation of pixel change Y: {std_y}')
        print(f'Mean of pixel change X: {mean_x}')
        print(f'Mean of pixel change Y: {mean_y}')

if __name__ == "__main__":
    main()
